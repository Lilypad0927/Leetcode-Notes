Problem: https://leetcode.com/problems/3sum/
         Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
         Notice that the solution set must not contain duplicate triplets.
Thought: First sort.
Java:
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        int length = nums.length;
        if (length < 3) return result;
        Arrays.sort(nums);
        if (nums[0] > 0 || nums[length - 1] < 0) return result;
        for (int i = 0; i < length - 2; i++){
            if (i > 0 && nums[i] == nums[i-1]) continue;
            int l = i+1;
            int r = length-1;
            while (l<r){
                int total = nums[i]+nums[l]+nums[r];
                if (total < 0) l++;
                else if (total > 0) r--;
                else {
                    List<Integer> temp = Arrays.asList(new Integer[] {nums[i], nums[l], nums[r]});
                    Collections.sort(temp);
                    if (!result.contains(temp)) result.add(temp);
                    while (l<r && nums[l]==nums[l+1]) l++;
                    while (l<r && nums[r]==nums[r-1]) r--;
                    l++;
                    r--;
                }
            }
        }
        return result;
    }
}

First attempt:
/*
        //nums = Arrays.stream(nums).distinct().toArray(); It's wrong to remove duplicates but need to know how
        for (int i = 0; i < length - 2; i++) {
            for (int j = i + 1; j < length - 1; j++) {
                for (int k = length - 1; k > j; k--) {
                    if (k == length - 1 && nums[i] + nums[j] + nums[k] < 0) break;
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        //List<Integer> temp = List.of(nums[i], nums[j], nums[k]); This will cause sort to crush
                        List<Integer> temp = Arrays.asList(new Integer[] {nums[i], nums[j], nums[k]});
                        Collections.sort(temp);
                        if (!result.contains(temp)) result.add(temp);
                    }
                }
            }
        }
*/
